#!/usr/bin/env fish

# Script: aicommit
# Version: 1.3.0
# Description: Generate AI-powered commit messages using Claude Code (haiku model)
# Installation: Copy to ~/bin/scripts

set VERSION "1.3.0"
set SCRIPT_NAME "aicommit"

# Prompt for Claude Code to generate commit message
set COMMIT_PROMPT "Analyze this git diff and generate a concise, professional commit message following conventional commit format. The message should have a short summary line (max 50 chars) and optionally a detailed body explaining the changes. Only output the commit message text, nothing else."

function log_info
    logger -t "$SCRIPT_NAME" -p user.info $argv
end

function log_error
    logger -t "$SCRIPT_NAME" -p user.error $argv
end

function log_debug
    logger -t "$SCRIPT_NAME" -p user.debug $argv
end

function show_version
    echo "$SCRIPT_NAME version $VERSION"
    exit 0
end

function usage
    echo "Usage: $SCRIPT_NAME [options]"
    echo ""
    echo "Description: Generate commit messages using Claude Code (haiku model)"
    echo "             If files are already staged, uses only those changes."
    echo "             Otherwise stages all changes unless --add-all is used."
    echo ""
    echo "Options:"
    echo "  -a, --add-all         Stage all changes (default: use only staged changes)"
    echo "  -t, --test            Run unit and regression tests"
    echo "  -h, --help            Show this help message"
    echo "  -v, --version         Show version information"
    echo "  --fish-completions    Install fish shell completions"
    echo ""
    echo "Environment:"
    echo "  EDITOR           Editor to use for reviewing commit message (default: nvim)"
    exit 0
end

function run_tests
    echo "================================"
    echo "aicommit Test Suite (v$VERSION)"
    echo "================================"
    echo ""

    set -l test_count 0
    set -l test_passed 0
    set -l test_failed 0

    # Unit Tests
    echo "--- Unit Tests ---"

    # Test 1: Non-git directory detection
    set test_count (math $test_count + 1)
    echo -n "Test $test_count: Non-git directory detection... "
    set tmpdir (mktemp -d)
    cd $tmpdir
    if not git rev-parse --git-dir >/dev/null 2>&1
        echo "PASS"
        set test_passed (math $test_passed + 1)
    else
        echo "FAIL"
        set test_failed (math $test_failed + 1)
    end
    rm -rf $tmpdir

    # Test 2: Help flag works
    set test_count (math $test_count + 1)
    echo -n "Test $test_count: Help flag works... "
    if $SCRIPT_NAME --help 2>&1 | grep -q "Usage:"
        echo "PASS"
        set test_passed (math $test_passed + 1)
    else
        echo "FAIL"
        set test_failed (math $test_failed + 1)
    end

    # Test 3: Version flag works
    set test_count (math $test_count + 1)
    echo -n "Test $test_count: Version flag works... "
    if $SCRIPT_NAME --version 2>&1 | grep -q "version"
        echo "PASS"
        set test_passed (math $test_passed + 1)
    else
        echo "FAIL"
        set test_failed (math $test_failed + 1)
    end

    # Regression Tests
    echo ""
    echo "--- Regression Tests ---"

    # Test 4: No changes detection
    set test_count (math $test_count + 1)
    echo -n "Test $test_count: No changes detection... "
    set tmpdir (mktemp -d)
    cd $tmpdir
    git init >/dev/null 2>&1
    git config user.email "test@example.com"
    git config user.name "Test User"
    touch initial.txt
    git add initial.txt
    git commit -m "Initial commit" >/dev/null 2>&1
    if $SCRIPT_NAME 2>&1 | grep -q "Nothing to commit"
        echo "PASS"
        set test_passed (math $test_passed + 1)
    else
        echo "FAIL"
        set test_failed (math $test_failed + 1)
    end
    rm -rf $tmpdir

    # Test 5: Staged changes detection
    set test_count (math $test_count + 1)
    echo -n "Test $test_count: Staged changes detection... "
    set tmpdir (mktemp -d)
    cd $tmpdir
    git init >/dev/null 2>&1
    git config user.email "test@example.com"
    git config user.name "Test User"
    touch initial.txt
    git add initial.txt
    git commit -m "Initial" >/dev/null 2>&1
    echo "modified" > test.txt
    git add test.txt
    if not git diff --cached --quiet
        echo "PASS"
        set test_passed (math $test_passed + 1)
    else
        echo "FAIL"
        set test_failed (math $test_failed + 1)
    end
    rm -rf $tmpdir

    # Test 6: Script is executable
    set test_count (math $test_count + 1)
    echo -n "Test $test_count: Script is executable... "
    if test -x (which $SCRIPT_NAME)
        echo "PASS"
        set test_passed (math $test_passed + 1)
    else
        echo "FAIL"
        set test_failed (math $test_failed + 1)
    end

    # Test 7: Only staged changes are used (not unstaged)
    set test_count (math $test_count + 1)
    echo -n "Test $test_count: Only uses staged changes, not unstaged... "
    set tmpdir (mktemp -d)
    cd $tmpdir
    git init >/dev/null 2>&1
    git config user.email "test@example.com"
    git config user.name "Test User"

    # Create initial commit
    echo "initial" > file1.txt
    git add file1.txt
    git commit -m "Initial" >/dev/null 2>&1

    # Stage a change to file1
    echo "staged change" > file1.txt
    git add file1.txt

    # Make additional unstaged changes to file1
    echo "unstaged change" > file1.txt

    # Create untracked file
    echo "untracked" > file2.txt

    # Verify that staged diff only shows staged changes, not unstaged/untracked
    set staged_diff (git diff --cached)
    set staged_has_staged (echo $staged_diff | grep -q "staged change" && echo "yes" || echo "no")
    set staged_has_unstaged (echo $staged_diff | grep -q "unstaged change" && echo "yes" || echo "no")
    set staged_has_untracked (echo $staged_diff | grep -q "untracked" && echo "yes" || echo "no")

    if test "$staged_has_staged" = "yes" && test "$staged_has_unstaged" = "no" && test "$staged_has_untracked" = "no"
        echo "PASS"
        set test_passed (math $test_passed + 1)
    else
        echo "FAIL"
        set test_failed (math $test_failed + 1)
    end
    rm -rf $tmpdir

    # Print summary
    echo ""
    echo "================================"
    echo "Test Results"
    echo "================================"
    echo "Total:  $test_count"
    echo "Passed: $test_passed"
    echo "Failed: $test_failed"
    echo ""

    if test $test_failed -eq 0
        echo "All tests passed!"
        return 0
    else
        echo "Some tests failed."
        return 1
    end
end

function main
    log_info "action=start status=checking_git_repo"

    # Check if we're in a git repository
    if not git rev-parse --git-dir >/dev/null 2>&1
        log_error "action=fail error=\"not a git repository\""
        echo "Error: Not a git repository"
        exit 1
    end

    # Check if there are any changes to commit
    if git diff --quiet && git diff --cached --quiet && not git ls-files --others --exclude-standard | grep -q .
        log_info "action=complete status=no_changes"
        echo "Nothing to commit - working tree is clean"
        exit 0
    end

    # Determine if we should stage all changes
    if set -q _flag_add_all
        # User explicitly requested --add-all, stage all changes
        log_info "action=staging status=adding_all_changes_flag"
        echo "Staging all changes (--add-all)..."
        git add -A
        if test $status -ne 0
            log_error "action=fail error=\"failed to stage changes\""
            echo "Error: Failed to stage changes"
            exit 1
        end
    else if not git diff --cached --quiet
        # Already have staged changes, use only those
        log_info "action=staging status=using_staged_changes"
        echo "Using already-staged changes..."
    else
        # No staged changes, stage all by default
        log_info "action=staging status=adding_all_changes"
        echo "Staging all changes..."
        git add -A
        if test $status -ne 0
            log_error "action=fail error=\"failed to stage changes\""
            echo "Error: Failed to stage changes"
            exit 1
        end
    end

    log_info "action=generate status=creating_commit_message"
    echo "Generating commit message with Claude Code (haiku model)..."

    # Create a temporary file for the commit message
    set temp_msg (mktemp)
    log_debug "action=create_temp file=\"$temp_msg\""

    # Generate commit message using Claude Code with haiku model
    # We'll ask Claude to analyze the staged diff and create a commit message
    git diff --cached | ~/.claude/local/claude --print --dangerously-skip-permissions --model haiku "$COMMIT_PROMPT" >$temp_msg 2>&1

    if test $status -ne 0
        log_error "action=fail error=\"claude-code failed\""
        echo "Error: Failed to generate commit message with Claude Code"
        rm -f $temp_msg
        exit 1
    end

    # Check if the generated message is empty
    if not test -s $temp_msg
        log_error "action=fail error=\"empty commit message generated\""
        echo "Error: Generated commit message is empty"
        rm -f $temp_msg
        exit 1
    end

    log_info "action=review status=opening_editor"
    echo "Opening commit message in editor for review..."

    # Open in editor for review
    set editor $EDITOR
    if test -z "$editor"
        set editor nvim
    end

    $editor $temp_msg
    if test $status -ne 0
        log_error "action=fail error=\"editor exited with error\""
        echo "Error: Editor exited with error"
        rm -f $temp_msg
        exit 1
    end

    # Check if message is still present and not empty after editing
    if not test -s $temp_msg
        log_info "action=abort status=empty_message"
        echo "Commit aborted: empty message"
        rm -f $temp_msg
        exit 1
    end

    log_info "action=commit status=creating_commit"
    echo "Creating commit..."

    # Commit with the edited message
    git commit -F $temp_msg
    set commit_status $status

    # Clean up temp file
    rm -f $temp_msg

    if test $commit_status -eq 0
        log_info "action=complete status=success"
        echo "Commit created successfully!"
    else
        log_error "action=fail error=\"git commit failed\" status=$commit_status"
        echo "Error: Commit failed"
        exit 1
    end
end

# Parse arguments
argparse 'a/add-all' 't/test' 'h/help' 'v/version' 'fish-completions' -- $argv
or begin
    usage
end

if set -q _flag_help
    usage
end

if set -q _flag_version
    show_version
end

if set -q _flag_test
    run_tests
    exit $status
end

# Handle --fish-completions flag
if set -q _flag_fish_completions
    set -l completions_file ~/.config/fish/completions/$SCRIPT_NAME.fish

    # Check if file already exists
    if test -f "$completions_file"
        echo "Error: Completions file already exists: $completions_file" >&2
        echo "Remove it first if you want to regenerate completions." >&2
        exit 1
    end

    # Ensure directory exists
    mkdir -p ~/.config/fish/completions

    # Generate and write completions
    echo "# Fish completions for $SCRIPT_NAME
# Generated by $SCRIPT_NAME --fish-completions

# Complete flags
complete -c $SCRIPT_NAME -s a -l add-all -d 'Stage all changes'
complete -c $SCRIPT_NAME -s t -l test -d 'Run unit and regression tests'
complete -c $SCRIPT_NAME -s h -l help -d 'Show help message'
complete -c $SCRIPT_NAME -s v -l version -d 'Show version information'
complete -c $SCRIPT_NAME -l fish-completions -d 'Install fish shell completions'
" > "$completions_file"

    and begin
        echo "Fish completions installed to: $completions_file"
        echo ""
        echo "Completions will be available in new fish shell sessions."
        echo "To use them immediately in this session, run:"
        echo "  source $completions_file"
        exit 0
    end
    or begin
        echo "Error: Failed to write completions file" >&2
        exit 1
    end
end

log_debug "action=init args=\"$argv\""
main
