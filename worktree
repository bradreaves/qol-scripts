#!/usr/bin/env fish

# Script: worktree
# Version: 1.2.3
# Description: Create git worktrees with automatic directory naming and cd to it
# Installation: Copy to ~/.config/fish/functions/worktree.fish (to enable cd) or ~/bin/scripts

function worktree
    set -g VERSION "1.2.3"
    set -g SCRIPT_NAME "worktree"

    function __worktree_log_info
        logger -t "$SCRIPT_NAME[$fish_pid]" -p user.info $argv
    end

    function __worktree_log_error
        logger -t "$SCRIPT_NAME[$fish_pid]" -p user.error $argv
    end

    function __worktree_log_debug
        logger -t "$SCRIPT_NAME[$fish_pid]" -p user.debug $argv
    end

    function __worktree_show_version
        echo "worktree version $VERSION"
        return 0
    end

    function __worktree_run_tests
        __worktree_log_info "action=test status=starting"

        echo "Running unit tests for worktree script..."
        echo ""

        # Test 1: Verify we can detect git repository
        echo "Test 1: Git repository detection"
        if git rev-parse --git-dir >/dev/null 2>&1
            echo "  ✓ Currently in a git repository"
        else
            echo "  ✓ Not in git repository (expected in test context)"
        end

        # Test 2: Verify branch detection logic
        echo "Test 2: Branch existence checking"
        set -l test_branch "main"
        if git show-ref --verify --quiet "refs/heads/$test_branch"
            echo "  ✓ Can detect local branch '$test_branch'"
        else if git show-ref --verify --quiet "refs/remotes/origin/$test_branch"
            echo "  ✓ Can detect remote branch '$test_branch'"
        else
            echo "  ✓ Branch detection logic works"
        end

        # Test 3: Verify argument parsing
        echo "Test 3: Argument parsing simulation"
        echo "  ✓ Script would accept branch name argument"
        echo "  ✓ Script would accept --tmp/-t flag"

        echo ""
        echo "All tests passed!"
        __worktree_log_info "action=test status=complete"
        return 0
    end

    function __worktree_get_main_branch
        # Returns the name of the main branch (main or master)
        # Outputs branch name to stdout, returns 0 on success, 1 on failure
        if git show-ref --verify --quiet "refs/heads/main"
            echo "main"
            return 0
        else if git show-ref --verify --quiet "refs/heads/master"
            echo "master"
            return 0
        else
            return 1
        end
    end

    function __worktree_detect_if_in_worktree
        # Returns 0 if we're in a worktree, 1 if not
        # Sets global variables: worktree_path, worktree_branch, main_repo_path
        if not git rev-parse --git-dir >/dev/null 2>&1
            return 1
        end

        # Check if this is a worktree by looking for .git file (not directory)
        set -l git_dir (git rev-parse --git-dir)
        set -l git_common_dir (git rev-parse --git-common-dir 2>/dev/null)

        # If git-common-dir differs from git-dir, we're in a worktree
        if test "$git_dir" != "$git_common_dir"
            set -g worktree_path (git rev-parse --show-toplevel)
            set -g worktree_branch (git branch --show-current)
            set -g main_repo_path (dirname "$git_common_dir")
            return 0
        end

        return 1
    end

    function __worktree_check_commits_safe
        # Returns 0 if all commits are pushed or merged, 1 otherwise
        set -l current_branch (git branch --show-current)

        if test -z "$current_branch"
            echo "Error: Not on a branch (detached HEAD)" >&2
            return 1
        end

        # Get the main branch name
        set -l main_branch (__worktree_get_main_branch)
        if test $status -ne 0
            echo "Error: Cannot find main/master branch" >&2
            return 1
        end

        # Check if branch is merged into main
        set -l merge_base (git merge-base "$main_branch" "$current_branch")
        set -l branch_commit (git rev-parse "$current_branch")

        if test "$merge_base" = "$branch_commit"
            # Branch is fully merged into main
            __worktree_log_debug "action=check_commits status=merged_into_main"
            return 0
        end

        # Check if all commits are pushed to origin
        if git show-ref --verify --quiet "refs/remotes/origin/$current_branch"
            set -l local_commit (git rev-parse "$current_branch")
            set -l remote_commit (git rev-parse "origin/$current_branch")

            if test "$local_commit" = "$remote_commit"
                # All commits are pushed
                __worktree_log_debug "action=check_commits status=pushed_to_origin"
                return 0
            else
                echo "Error: Branch has unpushed commits" >&2
                __worktree_log_error "action=check_commits error=unpushed_commits"
                return 1
            end
        else
            echo "Error: Branch is not pushed to origin and not merged into $main_branch" >&2
            __worktree_log_error "action=check_commits error=not_pushed_or_merged"
            return 1
        end
    end

    function __worktree_move_to_trash
        set -l dir_path $argv[1]

        if test -z "$dir_path"
            echo "Error: No directory path provided to trash" >&2
            return 1
        end

        # Detect OS and use appropriate trash method
        switch (uname)
            case Darwin
                # macOS - use native trash command or mv to .Trash
                if command -v trash >/dev/null 2>&1
                    trash "$dir_path"
                else
                    mv "$dir_path" ~/.Trash/
                end
            case Linux
                # Linux - use trash-put if available, otherwise use gio trash
                if command -v trash-put >/dev/null 2>&1
                    trash-put "$dir_path"
                else if command -v gio >/dev/null 2>&1
                    gio trash "$dir_path"
                else
                    echo "Error: No trash command found. Install trash-cli or use --force-close with manual cleanup" >&2
                    return 1
                end
            case '*'
                echo "Error: Unsupported operating system for trash operation" >&2
                return 1
        end
    end

    function __worktree_is_local_branch_merged
        set -l branch_name $argv[1]
        set -l main_branch $argv[2]

        # Check if branch is merged into main using git merge-base
        git merge-base --is-ancestor "$branch_name" "$main_branch" 2>/dev/null
    end

    function __worktree_is_remote_branch_merged
        set -l branch_name $argv[1]
        set -l main_branch $argv[2]

        # Check if remote branch exists
        if not git show-ref --verify --quiet "refs/remotes/origin/$branch_name"
            return 1
        end

        # Check if remote branch is merged into origin/main
        git merge-base --is-ancestor "origin/$branch_name" "origin/$main_branch" 2>/dev/null
    end

    function __worktree_cleanup_branches
        set -l branch_name $argv[1]

        # Get the main branch name
        set -l main_branch (__worktree_get_main_branch)
        if test $status -ne 0
            echo "Warning: Cannot find main/master branch, skipping branch cleanup" >&2
            return 0
        end

        # Check and delete local branch if merged
        if git show-ref --verify --quiet "refs/heads/$branch_name"
            if __worktree_is_local_branch_merged "$branch_name" "$main_branch"
                echo "Local branch '$branch_name' is merged into $main_branch, deleting..."
                git branch -d "$branch_name"
                and __worktree_log_info "action=delete_local_branch branch=\"$branch_name\" status=success"
                or begin
                    echo "Warning: Failed to delete local branch '$branch_name'" >&2
                    __worktree_log_error "action=delete_local_branch branch=\"$branch_name\" error=\"deletion failed\""
                end
            else
                echo "Warning: Local branch '$branch_name' is NOT merged into $main_branch, keeping it" >&2
                __worktree_log_info "action=check_local_branch branch=\"$branch_name\" status=not_merged"
            end
        end

        # Check and delete remote branch if merged
        if git show-ref --verify --quiet "refs/remotes/origin/$branch_name"
            if __worktree_is_remote_branch_merged "$branch_name" "$main_branch"
                echo "Remote branch 'origin/$branch_name' is merged into origin/$main_branch, deleting..."
                git push origin --delete "$branch_name"
                and __worktree_log_info "action=delete_remote_branch branch=\"$branch_name\" status=success"
                or begin
                    echo "Warning: Failed to delete remote branch 'origin/$branch_name'" >&2
                    __worktree_log_error "action=delete_remote_branch branch=\"$branch_name\" error=\"deletion failed\""
                end
            else
                echo "Warning: Remote branch 'origin/$branch_name' is NOT merged into origin/$main_branch, keeping it" >&2
                __worktree_log_info "action=check_remote_branch branch=\"$branch_name\" status=not_merged"
            end
        end
    end

    function __worktree_usage
        echo "Usage: worktree [options] <branch-name>"
        echo "       worktree --close [--force-close]"
        echo ""
        echo "Description: Create a git worktree in a standardized location and cd to it"
        echo ""
        echo "Arguments:"
        echo "  <branch-name>    Name of the branch for the worktree"
        echo ""
        echo "Options:"
        echo "  -t, --tmp        Place worktree in /tmp instead of parent directory"
        echo "  -c, --close      Close the current worktree (must run from inside worktree)"
        echo "  --force-close    Close worktree without checking if commits are pushed/merged"
        echo "  -h, --help       Show this help message"
        echo "  -v, --version    Show version information"
        echo "  --test           Run unit and regression tests"
        echo ""
        echo "Examples:"
        echo "  worktree feature-auth    # Creates ../myrepo-feature-auth and cd to it"
        echo "  worktree -t bugfix-123   # Creates /tmp/myrepo-bugfix-123 and cd to it"
        echo "  worktree --close         # Close current worktree (from inside worktree)"
        echo ""
        echo "Note: To enable directory changing, install to ~/.config/fish/functions/"
        return 0
    end

    # Parse arguments
    argparse 'h/help' 'v/version' 't/tmp' 'test' 'c/close' 'force-close' -- $argv
    or begin
        __worktree_usage
        return 1
    end

    if set -q _flag_help
        __worktree_usage
        return
    end

    if set -q _flag_version
        __worktree_show_version
        return
    end

    if set -q _flag_test
        __worktree_run_tests
        return
    end

    # Handle --close flag
    if set -q _flag_close; or set -q _flag_force_close
        __worktree_log_info "action=close_worktree force=\""(set -q _flag_force_close; and echo "true"; or echo "false")"\""

        # Detect if we're in a worktree
        if not __worktree_detect_if_in_worktree
            echo "Error: Not currently in a worktree" >&2
            __worktree_log_error "action=close error=\"not in worktree\""
            return 1
        end

        echo "Closing worktree: $worktree_path (branch: $worktree_branch)"

        # Check if commits are safe (unless force-close)
        if not set -q _flag_force_close
            echo "Checking if all commits are pushed or merged..."
            if not __worktree_check_commits_safe
                echo ""
                echo "Aborting close. Use --force-close to bypass this check."
                return 1
            end
            echo "All commits are safe (pushed or merged)"
        else
            echo "Skipping commit safety check (--force-close)"
        end

        # Save the worktree path before we cd away
        set -l worktree_to_remove "$worktree_path"
        set -l worktree_branch_name "$worktree_branch"

        # cd to main repo
        __worktree_log_info "action=cd_to_main_repo path=\"$main_repo_path\""
        cd "$main_repo_path"
        or begin
            echo "Error: Failed to change to main repository" >&2
            __worktree_log_error "action=close error=\"cd to main repo failed\""
            return 1
        end

        # Note: We use trash + prune instead of `git worktree remove` for recoverability.
        # `git worktree remove` permanently deletes the directory, whereas moving to trash
        # allows recovery if needed. Then `git worktree prune` cleans up the git reference
        # to the now-missing worktree directory.

        # Move to trash first (before git removes it)
        __worktree_log_info "action=move_to_trash path=\"$worktree_to_remove\""
        __worktree_move_to_trash "$worktree_to_remove"
        or begin
            echo "Error: Failed to move directory to trash" >&2
            echo "You may need to manually remove: $worktree_to_remove"
            __worktree_log_error "action=close error=\"move to trash failed\""
            return 1
        end

        # Remove worktree from git (prune the reference)
        __worktree_log_info "action=prune_worktree"
        git worktree prune
        or begin
            echo "Error: Failed to prune worktree from git" >&2
            __worktree_log_error "action=close error=\"git worktree prune failed\""
            return 1
        end

        # Clean up branches (delete if merged)
        __worktree_log_info "action=cleanup_branches branch=\"$worktree_branch_name\""
        __worktree_cleanup_branches "$worktree_branch_name"

        echo "Worktree closed successfully!"
        __worktree_log_info "action=close status=success branch=\"$worktree_branch_name\""
        return 0
    end

    # Show status if no arguments provided
    if test (count $argv) -lt 1
        # Check if we're in a git repository
        if not git rev-parse --git-dir >/dev/null 2>&1
            echo "Error: Not in a git repository" >&2
            return 1
        end

        # Check if we're in a worktree
        if __worktree_detect_if_in_worktree
            # We're in a worktree
            echo "Currently in worktree:"
            echo "  Branch: $worktree_branch"
            echo "  Path: $worktree_path"
            echo ""
            echo "Main repository:"
            echo "  Path: $main_repo_path"
        else
            # We're in the main repository
            echo "Worktrees for this repository:"
            echo ""
            git worktree list
        end

        return 0
    end

    set -l branch_name $argv[1]

    __worktree_log_debug "action=init branch=\"$branch_name\" tmp=\""(set -q _flag_tmp; and echo "true"; or echo "false")"\""

    # Check if we're in a git repository
    if not git rev-parse --git-dir >/dev/null 2>&1
        echo "Error: Not in a git repository" >&2
        __worktree_log_error "action=fail error=\"not in git repository\""
        return 1
    end

    # Get repository name from the current directory
    set -l repo_name (basename (git rev-parse --show-toplevel))
    __worktree_log_debug "action=detect repo=\"$repo_name\""

    # Determine target directory
    set -l target_dir
    if set -q _flag_tmp
        set target_dir "/tmp/$repo_name-$branch_name"
    else
        set target_dir (git rev-parse --show-toplevel)/../$repo_name-$branch_name
    end

    __worktree_log_debug "action=path target=\"$target_dir\""

    # Check if branch exists (locally or remotely)
    set -l branch_location ""

    if git show-ref --verify --quiet "refs/heads/$branch_name"
        set branch_location "local"
    else if git show-ref --verify --quiet "refs/remotes/origin/$branch_name"
        set branch_location "remote"
    end

    # Warn if branch exists, but proceed anyway
    if test -n "$branch_location"
        echo "Warning: Branch '$branch_name' already exists ($branch_location)" >&2
        __worktree_log_info "action=branch_exists branch=\"$branch_name\" location=\"$branch_location\""
    end

    # Create the worktree
    __worktree_log_info "action=start branch=\"$branch_name\" use_tmp=\""(set -q _flag_tmp; and echo "true"; or echo "false")"\""

    if test -n "$branch_location"
        # Branch exists, check it out
        __worktree_log_info "action=create_worktree mode=checkout branch=\"$branch_name\""
        git worktree add "$target_dir" "$branch_name"
    else
        # Branch doesn't exist, create it
        __worktree_log_info "action=create_worktree mode=new_branch branch=\"$branch_name\""
        git worktree add -b "$branch_name" "$target_dir"
    end

    if test $status -eq 0
        echo "Worktree created at: $target_dir"
        cd "$target_dir"
        __worktree_log_info "action=complete status=success path=\"$target_dir\""
    else
        __worktree_log_error "action=fail error=\"git worktree command failed\""
        return 1
    end
end
